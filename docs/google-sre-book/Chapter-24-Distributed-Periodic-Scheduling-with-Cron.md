# 使用 Cron 進行分散式定期排程

作者：Štěpán Davidovič 114

編輯：Kavita Guliani

本章描述了 Google 對分散式 cron 服務的實現，該服務為絕大多數需要定期排程計算工作的內部團隊提供服務。在 cron 的存在期間，我們學到了許多關於如何設計和實現一個看似基礎的服務的教訓。在這裡，我們討論分散式 cron 面臨的問題，並概述一些潛在的解決方案。

Cron 是一種常見的 Unix 工具，旨在於用戶定義的時間或間隔定期啟動任意作業。我們首先分析 cron 的基本原則及其最常見的實現，然後回顧像 cron 這樣的應用程式如何在大規模分散式環境中工作，以提高系統對單機故障的可靠性。我們描述了一個部署在少量機器上，但可以與像 Borg [Ver15] 這樣的資料中心排程系統結合，在整個資料中心啟動 cron 作業的分散式 cron 系統。

## Cron

在深入探討將 cron 作為跨資料中心服務運行之前，讓我們先討論 cron 在單機情況下通常是如何使用的。

### 介紹

Cron 的設計使得系統管理員和系統的普通用戶可以指定要運行的命令，以及這些命令的運行時間。Cron 執行各種類型的作業，包括垃圾收集和定期數據分析。最常見的時間規範格式稱為「crontab」。這種格式支持簡單的間隔（例如，「每天中午一次」或「每小時整點」）。也可以配置複雜的間隔，例如「每週六，同時也是該月的第 30 天」。

Cron 通常使用單個組件實現，通常稱為 **crond**。crond 是一個守護進程，它加載排程的 cron 作業列表。作業根據其指定的執行時間啟動。

### 可靠性視角

從可靠性的角度來看，cron 服務的幾個方面值得注意：

-   Cron 的故障域基本上只是一台機器。如果機器沒有運行，cron 排程器及其啟動的作業都無法運行。115 考慮一個非常簡單的兩台機器的分散式案例，其中您的 cron 排程器在不同的工作機器上啟動作業（例如，使用 SSH）。這種情況呈現了兩個可能影響我們啟動作業能力的獨立故障域：排程器機器或目標機器都可能失敗。
-   在 crond 重啟（包括機器重啟）之間唯一需要持久化的狀態是 crontab 配置本身。cron 的啟動是**發射後不管 (fire-and-forget)** 的，crond 不會嘗試追蹤這些啟動。
-   **anacron** 是這方面一個顯著的例外。anacron 試圖啟動那些在系統關機時本應啟動的作業。重新啟動的嘗試僅限於每天或更不頻繁運行的作業。此功能對於在工作站和筆記型電腦上運行維護作業非常有用，並且通過一個保留所有已註冊 cron 作業上次啟動時間戳的檔案來實現。

# Cron 作業與冪等性 (Cron Jobs and Idempotency)

Cron 作業旨在執行定期工作，但除此之外，很難預先知道它們有什麼功能。多樣化的 cron 作業所帶來的各種需求，顯然會影響可靠性要求。

一些 cron 作業，例如垃圾收集進程，是**冪等的 (idempotent)**。在系統故障的情況下，多次啟動此類作業是安全的。其他 cron 作業，例如向廣泛分發列表發送電子郵件通訊的進程，則不應多次啟動。

更複雜的是，對於某些 cron 作業來說，啟動失敗是可以接受的，但對於其他作業則不行。例如，一個排程為每五分鐘運行的垃圾收集 cron 作業可能會跳過一次啟動，但一個排程為每月運行一次的薪資 cron 作業則不應被跳過。

這種 cron 作業的巨大多樣性使得對故障模式的推理變得困難：在像 cron 服務這樣的系統中，沒有一個單一的答案適用於所有情況。總的來說，在基礎設施允許的範圍內，我們傾向于跳過啟動而不是冒著重複啟動的風險。這是因為從跳過的啟動中恢復比從重複啟動中恢復更可行。Cron 作業的所有者可以（也應該！）監控他們的 cron 作業；例如，所有者可能讓 cron 服務為其管理的 cron 作業暴露狀態，或者設置對 cron 作業效果的獨立監控。在跳過啟動的情況下，cron 作業所有者可以採取適當匹配 cron 作業性質的行動。然而，撤銷一次重複啟動，例如前面提到的通訊例子，可能很困難甚至完全不可能。因此，我們更喜歡「**失敗時關閉 (fail closed)**」以避免系統性地產生不良狀態。

# 大規模 Cron (Cron at Large Scale)

從單機轉向大規模部署，需要對如何使 cron 在這樣的環境中良好工作進行一些根本性的重新思考。在介紹 Google cron 解決方案的細節之前，我們將討論小規模和大規模部署之間的這些差異，並描述大規模部署所必需的設計變更。

## 擴展的基礎設施

在其「常規」實現中，cron 僅限於單台機器。大規模系統部署將我們的 cron 解決方案擴展到多台機器。

將您的 cron 服務託管在單台機器上，在可靠性方面可能是災難性的。假設這台機器位於一個恰好有 1,000 台機器的資料中心。您可用機器中僅 1/1000 的故障就可能使整個 cron 服務癱瘓。出於顯而易見的原因，這種實現是不可接受的。

為了提高 cron 的可靠性，我們將進程與機器解耦。如果您想運行一個服務，只需指定服務需求及其應運行的資料中心。資料中心排程系統（其本身應該是可靠的）決定將您的服務部署在哪台或哪些機器上，此外還處理機器的死亡。在資料中心啟動一個作業，實際上就變成了向資料中心排程器發送一個或多個 RPC。

然而，這個過程並不是瞬時的。發現一台死機需要健康檢查超時，而將您的服務重新排程到另一台機器上則需要時間來安裝軟體和啟動新進程。

因為將一個進程移動到不同的機器可能意味著舊機器上儲存的任何本地狀態的丟失（除非採用了即時遷移），並且重新排程的時間可能超過一分鐘的最小排程間隔，所以我們需要有程序來減輕數據丟失和過多的時間要求。為了保留舊機器的本地狀態，您可以簡單地將狀態持久化到像 GFS 這樣的**分散式檔案系統 (distributed filesystem)** 上，並在啟動時使用此檔案系統來識別因重新排程而未能啟動的作業。然而，這個解決方案在及時性期望方面有所欠缺：如果您每五分鐘運行一次 cron 作業，由 cron 系統重新排程的總開銷引起的一到兩分鐘的延遲可能是不可接受的。在這種情況下，**熱備份 (hot spares)**，能夠迅速介入並恢復操作，可以顯著縮短這個時間窗口。

## 擴展的需求

單機系統通常只是將所有運行的進程共置一處，隔離有限。雖然容器現在很普遍，但使用容器來隔離部署在單台機器上的服務的每一個組件並不是必要或常見的。因此，如果 cron 部署在單台機器上，crond 和它運行的所有 cron 作業很可能不會被隔離。

在資料中心規模的部署通常意味著部署到強制隔離的容器中。隔離是必要的，因為基本的期望是同一資料中心中運行的獨立進程不應相互產生負面影響。為了強制執行這一期望，您應該預先知道您想要運行的任何給定進程所需的資源量—— sowohl für das Cron-System als auch für die von ihm gestarteten Jobs。如果資料中心沒有可用資源來滿足 cron 作業的需求，cron 作業可能會被延遲。資源需求，加上用戶對 cron 作業啟動監控的需求，意味著我們需要追蹤我們 cron 作業啟動的完整狀態，從排程的啟動到終止。

將進程啟動與特定機器解耦，使 cron 系統面臨**部分啟動失敗 (partial launch failure)** 的風險。cron 作業配置的多樣性也意味著在資料中心啟動一個新的 cron 作業可能需要多個 RPC，因此有時我們會遇到一些 RPC 成功而另一些失敗的情況（例如，因為發送 RPC 的進程在執行這些任務的中途死亡）。cron 恢復程序也必須考慮到這種情況。

在故障模式方面，資料中心是一個比單台機器複雜得多的生態系統。最初在單台機器上作為一個相對簡單的二進位檔案的 cron 服務，在更大規模部署時現在有了許多明顯和不明顯的依賴關係。對於像 cron 這樣基礎的服務，我們希望確保即使資料中心遭受部分故障（例如，部分停電或儲存服務問題），該服務仍然能夠運作。通過要求資料中心排程器將 cron 的副本放置在資料中心內的不同位置，我們避免了單個配電單元故障導致 cron 服務所有進程癱瘓的情況。

在全球範圍內部署單個 cron 服務是可能的，但在單個資料中心內部署 cron 有其好處：該服務享有低延遲，並與資料中心排程器（cron 的核心依賴）共享命運。

# 在 Google 建立 Cron

本節討論了為了可靠地提供大規模分散式 cron 部署而必須解決的問題。它還強調了在 Google 就分散式 cron 作出的一些重要決定。

## 追蹤 Cron 作業的狀態

如前幾節所述，我們需要保留關於 cron 作業的一定數量的狀態，並能夠在發生故障時迅速恢復該資訊。此外，該狀態的一致性至關重要。回想一下，許多 cron 作業，如薪資運行或發送電子郵件通訊，都不是冪等的。

我們有兩種選擇來追蹤 cron 作業的狀態：

-   將數據外部儲存在普遍可用的分散式儲存中
-   使用一個系統，將少量狀態作為 cron 服務本身的一部分儲存

在設計分散式 cron 時，我們選擇了第二個選項。我們做出這個選擇有幾個原因：

-   像 GFS 或 HDFS 這樣的**分散式檔案系統 (Distributed filesystems)** 通常迎合非常大檔案的使用案例（例如，網路爬蟲程式的輸出），而我們需要儲存的關於 cron 作業的資訊非常小。在分散式檔案系統上進行小量寫入非常昂貴且延遲高，因為檔案系統並未針對這些類型的寫入進行優化。
-   對於中斷會產生廣泛影響的基礎服務（如 cron），應該有非常少的依賴。即使資料中心的部分區域消失，cron 服務也應該能夠在至少一段時間內運作。但這個要求並不意味著儲存必須直接成為 cron 進程的一部分（儲存如何處理本質上是一個實現細節）。然而，cron 應該能夠獨立於迎合大量內部用戶的下游系統運作。

## Paxos 的使用

我們部署了 cron 服務的多個副本，並使用 **Paxos** 分散式共識演算法（參見《管理關鍵狀態：用於可靠性的分散式共識》）來確保它們具有一致的狀態。只要大多數組成員可用，儘管基礎設施的有限子集發生故障，整個分散式系統仍然可以成功處理新的狀態變更。

如圖 24-1 所示，分散式 cron 使用單個**領導者作業 (leader job)**，它是唯一可以修改共享狀態的副本，也是唯一可以啟動 cron 作業的副本。我們利用了我們使用的 Paxos 變體 **Fast Paxos** [Lam06] 內部使用一個領導者副本作為優化的事實——Fast Paxos 領導者副本同時也充當 cron 服務的領導者。

如果領導者副本死亡，Paxos 組的健康檢查機制會迅速（在幾秒鐘內）發現這一事件。由於另一個 cron 進程已經啟動並可用，我們可以選舉一個新的領導者。一旦選出新的領導者，我們就遵循一個特定於 cron 服務的領導者選舉協議，該協議負責接管前一個領導者未完成的所有工作。特定於 cron 服務的領導者與 Paxos 領導者相同，但 cron 服務在晉升後需要採取額外的行動。領導者重新選舉的快速反應時間使我們能夠很好地保持在通常可容忍的一分鐘故障轉移時間內。

我們在 Paxos 中保留的最重要的狀態是關於哪些 cron 作業被啟動的資訊。我們同步地通知法定人數的副本每個排程的 cron 作業的每次啟動的開始和結束。

## 領導者與追隨者的角色

如剛才所述，我們對 Paxos 的使用及其在 cron 服務中的部署有兩個指定的角色：領導者和追隨者。以下各節描述了每個角色。

### 領導者 (The leader)

領導者副本是唯一積極啟動 cron 作業的副本。領導者有一個內部排程器，很像本章開頭描述的簡單 crond，它維護按其排程啟動時間排序的 cron 作業列表。領導者副本會等到第一個作業的排程啟動時間。

到達排程的啟動時間後，領導者副本會宣布它即將開始這個特定 cron 作業的啟動，並計算新的排程啟動時間，就像一個常規的 crond 實現一樣。當然，與常規 crond 一樣，一個 cron 作業的啟動規範可能自上次執行以來已經更改，並且這個啟動規範也必須與追隨者保持同步。僅僅識別 cron 作業是不夠的：我們還應該使用開始時間來唯一地識別特定的啟動；否則，可能會出現 cron 作業啟動追蹤的歧義。（這種歧義在高頻率的 cron 作業中尤其可能發生，例如那些每分鐘運行的作業。）如圖 24-2 所示，這種通訊是通過 Paxos 進行的。

重要的是 Paxos 通訊保持同步，並且在收到 Paxos 法定人數已收到啟動通知的確認之前，實際的 cron 作業啟動不會繼續。cron 服務需要了解每個 cron 作業是否已啟動，以便在領導者故障轉移的情況下決定下一步的行動。不同步地執行此任務可能意味著整個 cron 作業啟動都發生在領導者上，而沒有通知追隨者副本。在故障轉移的情況下，追隨者副本可能會嘗試再次執行完全相同的啟動，因為它們不知道該啟動已經發生。

cron 作業啟動的完成會通過 Paxos 同步地向其他副本宣布。請注意，無論啟動是因外部原因成功還是失敗（例如，如果資料中心排程器不可用），都無關緊要。在這裡，我們只是追蹤 cron 服務在給定的排程時間嘗試了啟動這一事實。我們還需要能夠解決在此操作中途 cron 系統的故障，如下一節所述。

領導者的另一個極其重要的特性是，一旦它因任何原因失去其領導地位，它必須立即停止與資料中心排程器的互動。持有領導地位應保證對資料中心排程器的互斥訪問。在沒有這種互斥條件的情況下，舊的和新的領導者可能會在資料中心排程器上執行相互衝突的操作。

### 追隨者 (The follower)

追隨者副本追蹤由領導者提供的世界狀態，以便在需要時隨時接管。追隨者副本追蹤的所有狀態變更都是通過 Paxos 從領導者副本傳達的。與領導者非常相似，追隨者也維護系統中所有 cron 作業的列表，並且這個列表必須在副本之間保持一致（通過使用 Paxos）。

在收到關於已開始啟動的通知後，追隨者副本會更新給定 cron 作業的本地下一個排程啟動時間。這個非常重要的狀態變更（同步執行）確保了系統內所有 cron 作業排程的一致性。我們追蹤所有開放的啟動（已開始但未完成的啟動）。

如果一個領導者副本死亡或以其他方式發生故障（例如，在網路上與其他副本分區），應該選舉一個追隨者作為新的領導者。選舉必須在一分鐘內收斂，以避免錯過或不合理地延遲 cron 作業啟動的風險。一旦選出領導者，所有開放的啟動（即部分失敗）都必須被結束。這個過程可能相當複雜，對 cron 系統和資料中心基礎設施都提出了額外的要求。下一節將討論如何解決這種類型的部分失敗。

### 解決部分失敗

如前所述，領導者副本與資料中心排程器之間的互動可能會在發送描述單個邏輯 cron 作業啟動的多個 RPC 之間失敗。我們的系統應該能夠處理這種情況。

回想一下，每個 cron 作業啟動都有兩個同步點：

-   當我們即將執行啟動時
-   當我們完成啟動時

這兩點讓我們能夠界定啟動的範圍。即使啟動只包含一個 RPC，我們如何知道該 RPC 是否真的被發送了？考慮這樣一種情況，我們知道排程的啟動已經開始，但在領導者副本死亡之前我們沒有收到其完成的通知。

為了確定 RPC 是否真的被發送，必須滿足以下條件之一：

-   在外部系統上的所有操作，我們可能需要在重新選舉後繼續執行，都必須是冪等的（即，我們可以安全地再次執行這些操作）
-   我們必須能夠查詢外部系統上所有操作的狀態，以便明確地確定它們是否已完成

這些條件中的每一個都施加了重大的約束，並且可能難以實現，但能夠滿足這些條件中的至少一個，對於在可能遭受單個或多個部分失敗的分散式環境中 cron 服務的準確操作至關重要。不恰當地處理這個問題可能導致錯過啟動或同一個 cron 作業的重複啟動。

大多數在資料中心啟動邏輯作業的基礎設施（例如 Mesos）都為這些資料中心作業提供了命名，從而可以查詢作業的狀態、停止作業或執行其他維護。對冪等性問題的一個合理 C 解決方案是提前構建作業名稱（從而避免在資料中心排程器上引起任何突變操作），然後將這些名稱分發給您的 cron 服務的所有副本。如果 cron 服務領導者在啟動期間死亡，新的領導者只需查詢所有預先計算的名稱的狀態，並啟動缺失的名稱。

請注意，與我們通過其名稱和啟動時間來識別單個 cron 作業啟動的方法類似，重要的是資料中心排程器上構建的作業名稱包含特定的排程啟動時間（或以其他方式可檢索此資訊）。在常規操作中，cron 服務在領導者失敗的情況下應該能快速故障轉移，但快速故障轉移並不總是發生。

回想一下，我們在維護副本之間的內部狀態時會追蹤排程的啟動時間。同樣，我們也需要通過使用排程的啟動時間來消除與資料中心排程器互動的歧義。例如，考慮一個生命週期短但運行頻繁的 cron 作業。cron 作業啟動，但在啟動被傳達給所有副本之前，領導者崩潰，並且發生了一次異常長的故障轉移——長到足以讓 cron 作業成功完成。新的領導者查詢 cron 作業的狀態，觀察到它的完成，並試圖再次啟動該作業。如果包含了啟動時間，新的領導者就會知道資料中心排程器上的作業是這次特定 cron 作業啟動的結果，而這次重複啟動就不會發生。

實際的實現有一個更複雜的狀態查詢系統，由底層基礎設施的實現細節驅動。然而，前述描述涵蓋了任何此類系統的與實現無關的要求。根據可用的基礎設施，您可能還需要考慮冒著重複啟動的風險與冒著跳過啟動的風險之間的權衡。

## 儲存狀態 (Storing the State)

使用 Paxos 達成共識只是如何處理狀態問題的一部分。Paxos 本質上是一個狀態變更的連續日誌，隨著狀態變更的發生而同步附加。Paxos 的這一特性有兩個含義：

-   日誌需要被壓縮，以防止其無限增長
-   日誌本身必須儲存在某個地方

為了防止 Paxos 日誌的無限增長，我們可以簡單地對當前狀態進行快照，這意味著我們可以重建狀態而無需重播導致當前狀態的所有狀態變更日誌條目。舉個例子：如果我們儲存在日誌中的狀態變更是「將計數器加 1」，那麼經過一千次迭代後，我們有一千個日誌條目，可以很容易地更改為「將計數器設置為 1,000」的快照。

如果日誌丟失，我們只會丟失自上次快照以來的狀態。快照實際上是我們最關鍵的狀態——如果我們丟失了快照，我們基本上必須從零開始，因為我們已經失去了我們的內部狀態。另一方面，丟失日誌只會導致有限的狀態丟失，並將 cron 系統的時間倒退到拍攝最新快照的時間點。

我們有兩種主要選擇來儲存我們的數據：

-   外部儲存在普遍可用的分散式儲存中
-   在一個將少量狀態作為 cron 服務本身一部分儲存的系統中

在設計系統時，我們結合了兩種選擇的元素。

我們將 Paxos 日誌儲存在排程 cron 服務副本的機器的本地磁碟上。在預設操作中有三個副本意味著我們有三份日誌的副本。我們也將快照儲存在本地磁碟上。然而，因為它們是關鍵的，我們也將它們備份到一個分散式檔案系統上，從而防止影響所有三台機器的故障。

我們不將日誌儲存在我們的分散式檔案系統上。我們有意識地決定，丟失代表少量最新狀態變更的日誌是一個可接受的風險。將日誌儲存在分散式檔案系統上可能會因頻繁的小量寫入而帶來巨大的性能損失。同時丟失所有三台機器的可能性很小，如果確實發生了同時丟失，我們會自動從快照中恢復。因此，我們只會丟失少量的日誌：那些自上次快照以來拍攝的日誌，我們按可配置的間隔執行快照。當然，這些權衡可能會因基礎設施的細節以及對 cron 系統的要求而有所不同。

除了儲存在本地磁碟上的日誌和快照以及分散式檔案系統上的快照備份外，一個剛啟動的副本可以通過網路從一個已經運行的副本中獲取狀態快照和所有日誌。這種能力使得副本的啟動獨立於本地機器上的任何狀態。因此，在重啟（或機器死亡）時將副本重新排程到不同的機器，對於服務的可靠性來說基本上不是問題。

## 運行大型 Cron (Running Large Cron)

運行大型 cron 部署還有其他一些較小但同樣有趣的含義。傳統的 cron 很小：最多可能包含數十個 cron 作業。然而，如果您為資料中心中的數千台機器運行一個 cron 服務，您的使用量將會增長，您可能會遇到問題。

要警惕分散式系統中那個巨大且眾所周知的問題：**驚群效應 (thundering herd)**。根據用戶配置，cron 服務可能導致資料中心使用率的顯著尖峰。當人們想到「每日 cron 作業」時，他們通常會將此作業配置為在午夜運行。如果 cron 作業在同一台機器上啟動，這種設置工作得很好，但是如果您的 cron 作業可以產生一個有數千個工作者的 MapReduce 呢？如果 30 個不同的團隊決定在同一個資料中心運行這樣的每日 cron 作業呢？為了解決這個問題，我們對 crontab 格式進行了擴展。

在普通的 crontab 中，用戶指定 cron 作業應該啟動的分鐘、小時、月份中的日期（或星期）、和月份，或者用星號來指定任何值。每天午夜運行，那麼 crontab 規範就是「0 0 * * *」（即第零分鐘，第零小時，每週的每一天，每個月，以及每週的每一天）。我們還引入了問號的使用，這意味著任何值都是可接受的，cron 系統有權選擇該值。用戶通過對給定時間範圍（例如，小時為 0..23）的 cron 作業配置進行哈希來選擇這個值，從而更均勻地分配這些啟動。

儘管有此更改，由 cron 作業引起的負載仍然非常尖峰。圖 24-3 中的圖表說明了 Google 全球 cron 作業啟動的總數。該圖表突顯了 cron 作業啟動的頻繁尖峰，這通常是由於需要在特定時間啟動的 cron 作業引起的——例如，由於對外部事件的時間依賴性。

# 總結 (Summary)

Cron 服務幾十年來一直是 UNIX 系統的一個基本特性。行業向大型分散式系統的轉變，其中資料中心可能是硬體的最小有效單元，要求在堆疊的大部分進行更改。Cron 也不例外於這一趨勢。對 cron 服務所需屬性和 cron 作業要求的仔細審視，推動了 Google 的新設計。

我們討論了分散式系統環境所要求的新約束，以及基於 Google 解決方案的 cron 服務的可能設計。該解決方案要求在分散式環境中有強的一致性保證。因此，分散式 cron 實現的核心是 Paxos，這是在不可可靠環境中達成共識的常用演算法。Paxos 的使用以及對大規模分散式環境中 cron 作業新故障模式的正確分析，使我們能夠建立一個在 Google 被大量使用的穩健的 cron 服務。

114 本章部分內容先前曾發表於 ACM Queue（2015 年 3 月，第 13 卷，第 3 期）。

115 個別作業的失敗超出了本分析的範圍。