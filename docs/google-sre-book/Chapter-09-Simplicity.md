# 簡潔性 (Simplicity)

作者：Max Luebbe 編輯：Tim Harvey

> 可靠性的代價是追求極致的簡潔。
>
> C.A.R. Hoare，圖靈獎演講

軟體系統本質上是動態且不穩定的。38 一個軟體系統只有在真空中才能完美穩定。如果我們停止更改程式碼庫，我們就停止引入錯誤。如果底層硬體或函式庫永不改變，這些組件都不會引入錯誤。如果我們凍結當前的用戶群，我們就永遠不必擴展系統。事實上，對 SRE 管理系統方法的一個很好的總結是：「歸根結底，我們的工作是在系統中保持敏捷性與穩定性的平衡。」39

# 系統穩定性與敏捷性

有時為了敏捷性而犧牲穩定性是有意義的。我經常通過我稱之為**探索性編碼 (exploratory coding)** 的方式來處理一個不熟悉的問題領域——為我編寫的任何程式碼設定一個明確的保質期，並理解我需要嘗試並失敗一次，才能真正理解我需要完成的任務。帶有到期日的程式碼可以在測試覆蓋率和發布管理方面更加自由，因為它永遠不會被發布到生產環境或被用戶看到。

對於大多數**生產軟體系統 (production software systems)**，我們希望在穩定性和敏捷性之間取得平衡。SRE 致力於創建使軟體更可靠的程序、實踐和工具。同時，SRE 確保這項工作對開發人員的敏捷性影響盡可能小。事實上，SRE 的經驗發現，可靠的流程實際上往往會**增加**開發人員的敏捷性：快速、可靠的生產部署使生產中的變更更容易被看到。結果，一旦一個錯誤浮現，找到並修復該錯誤所需的時間就更少。將可靠性融入開發中，可以讓開發人員將注意力集中在我們真正關心的事情上——他們軟體和系統的功能和性能。

# 無聊的美德

與生活中幾乎所有其他事情不同，「無聊」在軟體方面實際上是一個積極的屬性！我們不希望我們的程式是自發的和有趣的；我們希望它們遵守腳本，並可預測地完成其業務目標。用 Google 工程師 Robert Muth 的話來說：「與偵探故事不同，缺乏興奮、懸念和謎題實際上是原始碼的一個理想屬性。」生產中的意外是 SRE 的剋星。

正如 Fred Brooks 在他的「沒有銀彈」文章 [Bro95] 中所建議的，考慮**本質複雜性 (essential complexity)** 和**偶然複雜性 (accidental complexity)** 之間的區別非常重要。本質複雜性是給定情況下固有的、無法從問題定義中移除的複雜性，而偶然複雜性則更具流動性，可以通過工程努力來解決。例如，編寫一個網頁伺服器需要處理快速提供網頁的本質複雜性。然而，如果我們用 Java 編寫一個網頁伺服器，當我們試圖最小化垃圾收集的性能影響時，我們可能會引入偶然複雜性。

為了最小化偶然複雜性，SRE 團隊應該：

- 當偶然複雜性被引入他們負責的系統時，予以抵制
- 不斷努力消除他們接管並承擔運營責任的系統中的複雜性

# 我不會放棄我的程式碼！

因為工程師是人類，他們常常對自己的創作產生情感依戀，所以對原始碼樹的大規模清理引發的對抗並不少見。有些人可能會抗議：「如果我們以後需要那段程式碼怎麼辦？」「為什麼我們不直接把程式碼註釋掉，以便以後可以輕鬆地再加回來？」「為什麼我們不用一個標誌來限制程式碼，而不是刪除它？」這些都是糟糕的建議。原始碼控制系統可以輕鬆地撤銷變更，而數百行被註釋的程式碼會造成干擾和混亂（尤其是在原始碼檔案不斷演變的情況下），而從未執行、被一個總是禁用的標誌限制的程式碼，就像一個隱喻的定時炸彈，隨時可能爆炸，例如 Knight Capital 的慘痛經歷（請參閱「關於 Knight Capital Americas LLC 的命令」[Sec13]）。

冒著聽起來極端的風險，當您考慮一個期望 24/7 可用的網頁服務時，在某種程度上，編寫的每一行新程式碼都是一個**負債 (liability)**。SRE 提倡的實踐使得所有程式碼都更有可能具有其本質目的，例如審查程式碼以確保其確實推動業務目標，定期刪除無用程式碼，以及在所有測試層級中建立膨脹檢測。

# 「負程式碼行數」指標

「軟體膨脹 (software bloat)」一詞被創造出來，用來描述軟體隨著時間的推移，由於不斷增加的功能而變得越來越慢、越來越大的趨勢。雖然膨脹的軟體直觀上看起來不受歡迎，但從 SRE 的角度來看，其負面影響變得更加清晰：對專案進行更改或添加的每一行程式碼都可能引入新的缺陷和錯誤。一個較小的專案更容易理解、更容易測試，並且通常缺陷更少。考慮到這個觀點，當我們有衝動為專案添加新功能時，我們或許應該有所保留。我做過的一些最令人滿意的程式碼撰寫工作，是在程式碼不再有用時一次性刪除數千行。

# 最小化 API

法國詩人安東尼·聖修伯里寫道：「完美最終不是在沒有更多東西可以添加時達到的，而是在沒有任何東西可以拿走時達到的」[Sai39]。這個原則也適用於軟體的設計和建構。API 是為什麼應該遵循這條規則的一個特別清晰的表達。

編寫清晰、最小化的 API 是管理軟體系統中簡潔性的一個重要方面。我們提供給 API 消費者的方法和參數越少，該 API 就越容易理解，我們也就能投入越多的精力使這些方法盡可能地好。同樣，一個反覆出現的主題出現了：有意識地決定不承擔某些問題，讓我們能夠專注於我們的核心問題，並使我們明確要創造的解決方案實質上更好。在軟體中，少即是多！一個小而簡單的 API 通常也是一個被充分理解的問題的標誌。

# 模組化

從 API 和單個二進位檔案向外擴展，許多適用於物件導向程式設計的經驗法則也適用於分散式系統的設計。能夠孤立地對系統的各個部分進行更改，對於創建一個可支援的系統至關重要。具體來說，二進位檔案之間，或二進位檔案與配置之間的**鬆散耦合 (loose coupling)**，是一種簡潔性模式，它同時促進了開發人員的敏捷性和系統的穩定性。如果在一個作為較大系統組件的程式中發現了一個錯誤，該錯誤可以被修復並獨立於系統的其餘部分推送到生產環境。

雖然 API 提供的模組化可能看起來很直接，但模組化的概念也擴展到如何引入對 API 的變更，這一點並非那麼明顯。僅僅對 API 的一次變更就可能迫使開發人員重建他們的整個系統，並冒著引入新錯誤的風險。對 API 進行版本控制，可以讓開發人員在以安全、深思熟慮的方式升級到新版本的同時，繼續使用他們系統所依賴的版本。發布節奏可以在整個系統中有所不同，而不必在每次添加或改進功能時都要求對整個系統進行全面的生產推送。

隨著系統變得越來越複雜，API 之間以及二進位檔案之間的職責分離變得越來越重要。這與物件導向的類別設計有直接的類比：正如人們普遍認為編寫一個包含不相關函式的「雜物袋」類別是不好的做法一樣，創建並投入生產一個「工具 (util)」或「雜項 (misc)」二進位檔案也是不好的做法。一個設計良好的分散式系統由協作者組成，每個協作者都有一個清晰且範圍明確的目的。

模組化的概念也適用於資料格式。Google 的**協定緩衝區 (protocol buffers)** 40 的核心優勢和設計目標之一，就是創建一種向後和向前相容的有線格式。

# 發布的簡潔性

簡單的發布通常比複雜的發布要好。衡量和理解單個變更的影響，比同時發布一批變更要容易得多。如果我們同時向一個系統發布 100 個不相關的變更，並且性能變差，那麼理解哪些變更影響了性能，以及它們是如何影響的，將需要相當大的努力或額外的儀器檢測。如果發布以較小的批次進行，我們可以更有信心地更快地行動，因為每個程式碼變更都可以在較大的系統中被孤立地理解。這種發布方法可以與機器學習中的梯度下降相比較，在梯度下降中，我們通過一次一小步來找到最佳解，並考慮每個變更是否帶來了改進或退化。

# 一個簡單的結論

本章反覆重複一個主題：軟體簡潔性是可靠性的先決條件。當我們考慮如何簡化給定任務的每一步時，我們並不是在偷懶。相反，我們是在澄清我們真正想要完成的是什麼，以及我們如何能最輕鬆地做到這一點。每一次我們對一個功能說「不」，我們並不是在限制創新；我們是在保持環境整潔，不受干擾，以便焦點始終 squarely on 創新，真正的工程才能繼續進行。

38 這通常適用於一般複雜系統；請參閱 [Per99] 和 [Coo00]。

39 由我的前任經理 Johan Anderson 在我成為 SRE 左右時創造。

40 協定緩衝區，也稱為「protobufs」，是一種語言中立、平台中立的可擴展機制，用於序列化結構化資料。有關更多詳細資訊，請參閱 https://developers.google.com/protocol-buffers/docs/overview#a-bit-of-history。