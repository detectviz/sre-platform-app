# 來自時間序列資料的實用警報

作者：Jamie Wilkinson 編輯：Kavita Guliani

> 願查詢暢通無阻，呼叫器保持沉默。
>
> 傳統 SRE 祝福語

監控，作為**生產需求層次結構 (Hierarchy of Production Needs)** 的底層，是運行穩定服務的基礎。監控使服務所有者能夠就服務變更的影響做出理性決策，將科學方法應用於事件回應，當然還有確保其存在的理由：衡量服務與業務目標的一致性（請參閱「監控分散式系統」）。

無論一個服務是否得到 SRE 的支持，它都應該與其監控系統處於一種共生關係中。但由於被賦予了對 Google 生產環境的最終責任，SRE 對支持其服務的監控基礎設施有著特別深入的了解。

監控一個非常大的系統是具有挑戰性的，原因有幾個：

- 被分析的組件數量龐大
- 需要為負責系統的工程師維持一個合理的低維護負擔

Google 的監控系統不僅僅測量簡單的指標，例如一台空載的歐洲網頁伺服器的平均響應時間；我們還需要了解該地區所有網頁伺服器響應時間的分佈。這些知識使我們能夠識別導致延遲尾部的因素。

在我們系統運營的規模上，因單機故障而發出警報是不可接受的，因為這樣的資料噪音太大，無法採取行動。相反，我們試圖建立對其所依賴系統的故障具有魯棒性的系統。一個大型系統不應要求管理許多單獨的組件，而應被設計為匯總信號並修剪異常值。我們需要能夠讓我們對高層服務目標發出警報，但又保留在需要時檢查單個組件的粒度的監控系統。

Google 的監控系統在 10 年的時間裡，從傳統的自訂腳本檢查響應並發出警報，與趨勢的視覺化顯示完全分離的模型，演變為一個新的範式。這個新模型將時間序列的收集作為監控系統的一等公民角色，並用一種豐富的語言取代了那些檢查腳本，用於將時間序列操作成圖表和警報。

## Borgmon 的崛起

在 2003 年作業排程基礎設施 Borg [Ver15] 創建後不久，一個新的監控系統 Borgmon 被建立起來作為其補充。

本章描述了一個內部監控工具的架構和程式設計介面，該工具在將近 10 年的時間裡是 Google 增長和可靠性的基礎……但這對您，我們親愛的讀者，有何幫助？

近年來，監控經歷了一次寒武紀大爆發：Riemann、Heka、Bosun 和 Prometheus 作為開源工具出現，它們與 Borgmon 基於時間序列的警報非常相似。特別是 Prometheus 42 與 Borgmon 有許多相似之處，尤其是在比較兩種規則語言時。變數收集和規則評估的原則在所有這些工具中都保持不變，並提供了一個環境，您可以在其中實驗，並希望將本章啟發的想法投入生產。

Borgmon 不再執行自訂腳本來檢測系統故障，而是依賴於一個通用的資料暴露格式；這使得能夠以低開銷進行大規模資料收集，並避免了子進程執行和網路連接設定的成本。我們稱之為**白盒監控 (white-box monitoring)**（關於白盒監控與黑盒監控的比較，請參閱「監控分散式系統」）。

這些資料既用於繪製圖表，也用於創建警報，這些都是通過簡單的算術運算完成的。由於收集不再是在一個短生命週期的進程中，收集到的資料的歷史記錄也可以用於該警報的計算。

這些特性有助於達到「監控分散式系統」中描述的簡單性目標。它們使系統開銷保持在較低水平，以便運行服務的人員能夠保持敏捷，並應對系統在增長過程中的持續變化。

為了方便大規模收集，指標格式必須標準化。一種較舊的匯出內部狀態的方法（稱為 **varz**）43 被正式化，以允許在一次 HTTP 獲取中從單個目標收集所有指標。例如，要手動查看一個指標頁面，您可以使用以下命令：

```
http_requests 37
errors_total 12
```

一個 Borgmon 可以從其他 Borgmon 44 收集資料，因此我們可以建立遵循服務拓撲的層次結構，在每個層級上匯總和總結資訊，並策略性地丟棄一些資訊。通常，一個團隊每個叢集運行一個 Borgmon，在全球層級運行一對。一些非常大的服務在叢集層級以下會分片到許多**抓取器 (scraper)** Borgmon，這些抓取器再將資料饋送給叢集層級的 Borgmon。

# 應用程式的儀器檢測

`/varz` HTTP 處理程序只是以純文本形式列出所有匯出的變數，以空格分隔的鍵和值，每行一個。後來的一個擴展增加了一個**對應變數 (mapped variable)**，它允許匯出器在一個變數名上定義多個標籤，然後匯出一張值表或一個直方圖。一個對應值變數的例子如下所示，顯示了 25 個 HTTP 200 回應和 12 個 HTTP 500 回應：

在程式中添加一個指標只需要在需要該指標的程式碼中進行一次聲明。

事後看來，很明顯，這種無模式的文本介面使得添加新儀器檢測的門檻非常低，這對軟體工程和 SRE 團隊都是一個積極的因素。然而，這與持續的維護存在權衡；變數定義與其在 Borgmon 規則中的使用之間的解耦需要謹慎的變更管理。在實踐中，這種權衡是令人滿意的，因為也編寫了用於驗證和生成規則的工具。45

Google 的網路根基深厚：在 Google 使用的每種主要語言都有一個匯出變數介面的實現，該介面會自動註冊到預設內建於每個 Google 二進位檔案中的 HTTP 伺服器。46 要匯出的變數的實例允許伺服器作者執行明顯的操作，如將一個數量添加到當前值，將一個鍵設定為特定值等等。Go 的 `expvar` 函式庫 47 及其 JSON 輸出形式具有此 API 的一個變體。

# 匯出資料的收集

為了找到其目標，一個 Borgmon 實例被配置了一個目標列表，該列表使用多種名稱解析方法之一。48 目標列表通常是動態的，因此使用服務發現可以降低維護成本並允許監控擴展。

在預定的間隔，Borgmon 獲取每個目標上的 `/varz` URI，解碼結果，並將值儲存在記憶體中。Borgmon 還將來自目標列表中每個實例的收集分散到整個間隔內，這樣來自每個目標的收集就不會與其同伴同步。

Borgmon 還為每個目標記錄「合成」變數，以識別：

- 名稱是否被解析為主機和埠
- 目標是否回應了收集
- 目標是否回應了健康檢查
- 收集完成的時間

這些合成變數使得編寫規則來檢測被監控的任務是否不可用變得容易。

有趣的是，`varz` 與 SNMP（簡單網路管理協定）非常不同，後者「旨在……具有最小的傳輸要求，並在大多數其他網路應用程式失敗時繼續工作」[Mic03]。通過 HTTP 抓取目標似乎與此設計原則相悖；然而，經驗表明這很少成為問題。49 系統本身已經被設計為對網路和機器故障具有魯棒性，Borgmon 允許工程師通過將收集失敗本身作為信號來編寫更智慧的警報規則。

# 時間序列競技場中的儲存

一個服務通常由許多運行在許多機器上、許多叢集中的許多任務的許多二進位檔案組成。Borgmon 需要將所有這些資料組織起來，同時允許對這些資料進行靈活的查詢和切片。

Borgmon 將所有資料儲存在一個記憶體資料庫中，並定期將其檢查點到磁碟。資料點的形式為 `(時間戳, 值)`，並儲存在稱為**時間序列 (time-series)** 的按時間順序排列的列表中，每個時間序列都由一組唯一的**標籤 (labels)** 命名，形式為 `名稱=值`。
如圖 10-1 所示，一個時間序列在概念上是一個一維的數字矩陣，隨時間推移。當您向這個時間序列添加標籤的排列組合時，該矩陣變為多維。

在實踐中，該結構是一個固定大小的記憶體塊，稱為**時間序列競技場 (time-series arena)**，帶有一個垃圾收集器，一旦競技場已滿，它就會使最舊的條目過期。競技場中最新和最舊條目之間的時間間隔是**視界 (horizon)**，它表示在 RAM 中保留了多少可查詢的資料。通常，資料中心和全域 Borgmon 的大小被設定為能夠容納大約 12 小時的資料 50 用於呈現控制台，如果它們是最低層的收集器分片，則時間要短得多。單個資料點的記憶體需求約為 24 位元組，因此我們可以在不到 17 GB 的 RAM 中容納 100 萬個唯一的、以 1 分鐘為間隔的時間序列，持續 12 小時。

記憶體中的狀態會定期歸檔到一個稱為**時間序列資料庫 (Time-Series Database, TSDB)** 的外部系統。Borgmon 可以查詢 TSDB 以獲取更舊的資料，雖然速度較慢，但 TSDB 比 Borgmon 的 RAM 更便宜且更大。

## 標籤和向量

如圖 10-2 中的範例時間序列所示，時間序列被儲存為數字和時間戳的序列，這些序列被稱為**向量 (vectors)**。就像線性代數中的向量一樣，這些向量是競技場中資料點多維矩陣的切片和橫截面。從概念上講，可以忽略時間戳，因為值是以固定的時間間隔插入向量中的——例如，相隔 1 秒、10 秒或 1 分鐘。

時間序列的名稱是一個**標籤集 (labelset)**，因為它是以一組表示為 `鍵=值` 對的標籤來實現的。其中一個標籤是變數名稱本身，即出現在 `varz` 頁面上的鍵。

一些標籤名稱被聲明為重要。為了使時間序列資料庫中的時間序列能夠被識別，它至少必須具有以下標籤：

這些變數一起出現時，看起來像下面這樣，稱為**變數表達式 (variable expression)**：

查詢一個時間序列不需要指定所有這些標籤，搜索一個標籤集會返回一個向量中所有匹配的時間序列。因此，如果叢集中有多個實例，我們可以通過在前面的查詢中移除 `instance` 標籤來返回一個結果向量。例如：
`{var=http_requests,job=webserver,user=shakespeare}`
可能會得到一個包含五行的向量結果，其中時間序列的最新值如下：

```
{var=http_requests,job=webserver,user=shakespeare,instance=0} 37
{var=http_requests,job=webserver,user=shakespeare,instance=1} 12
{var=http_requests,job=webserver,user=shakespeare,instance=2} 41
{var=http_requests,job=webserver,user=shakespeare,instance=3} 22
{var=http_requests,job=webserver,user=shakespeare,instance=4} 9
```

標籤可以從以下來源添加到時間序列中：

- 目標的名稱，例如，工作和實例
- 目標本身，例如，通過對應值變數
- Borgmon 配置，例如，關於位置或重新標記的註釋
- 正在評估的 Borgmon 規則

我們也可以按時間查詢時間序列，通過為變數表達式指定一個持續時間：

`http_requests[10m]`

這會返回匹配該表達式的時間序列過去 10 分鐘的歷史記錄。如果我們每分鐘收集一次資料點，我們預計在 10 分鐘的窗口內會返回 10 個資料點，如下所示：51

`{var=http_requests,job=webserver,user=shakespeare,instance=0} (14:00:00, 37), (14:01:00, 39), ...`

# 規則評估

Borgmon 實際上只是一個可程式設計的計算器，帶有一些語法糖，使其能夠生成警報。前面描述的資料收集和儲存組件只是為了使這個可程式設計的計算器最終適合其在這裡作為監控系統的目的而存在的必要之惡。:)

將規則評估集中在一個監控系統中，而不是將其委託給分叉的子進程，意味著計算可以針對許多相似的目標並行運行。這種做法使配置的規模相對較小（例如，通過消除程式碼的重複），但通過其表達能力而更加強大。

Borgmon 程式碼，也稱為 **Borgmon 規則**，由簡單的代數表達式組成，這些表達式從其他時間序列計算出新的時間序列。這些規則可能非常強大，因為它們可以查詢單個時間序列的歷史（即時間軸），一次查詢來自許多時間序列的標籤的不同子集（即空間軸），並應用許多數學運算。

規則在可能的情況下在一個並行執行緒池中運行，但在使用先前定義的規則作為輸入時，則依賴於順序。其查詢表達式返回的向量的大小也決定了規則的總體運行時。因此，通常情況下，可以為一個運行緩慢的 Borgmon 任務增加 CPU 資源來應對。為了協助更詳細的分析，會匯出關於規則運行時的內部指標，用於性能除錯和監控監控系統本身。

**匯總 (Aggregation)** 是分散式環境中規則評估的基石。匯總需要將來自一個工作中所有任務的一組時間序列求和，以便將該工作視為一個整體。從這些總和中，可以計算出總體速率。例如，一個資料中心中一個工作的總每秒查詢速率是所有查詢計數器的所有**變化率 (rates of change)** 52 的總和。53

**計數器 (counter)** 是任何單調不減的變數——也就是說，計數器的值只會增加。另一方面，**儀表 (gauges)** 可以取任何它們喜歡的值。計數器測量增加的值，例如總行駛公里數，而儀表顯示當前狀態，例如剩餘燃料量或當前速度。在收集 Borgmon 風格的資料時，最好使用計數器，因為當事件在採樣間隔之間發生時，它們不會失去意義。如果在採樣間隔之間發生任何活動或變化，儀表收集很可能會錯過該活動。

對於一個範例網頁伺服器，我們可能希望在我們的網頁伺服器叢集開始提供比我們認為正常的更多的錯誤百分比時發出警報——或者更技術性地說，當叢集中所有任務的非 HTTP-200 返回碼的速率總和，除以該叢集中所有任務的請求速率總和，大於某個值時。

這是通過以下方式實現的：

1.  匯總所有任務的回應碼速率，在該時間點輸出一個速率向量，每個碼一個。
2.  計算總錯誤率作為該向量的總和，在該時間點為叢集輸出一個單一值。這個總錯誤率從總和中排除了 200 碼，因為它不是錯誤。
3.  計算叢集範圍內的錯誤與請求的比率，將總錯誤率除以到達的請求速率，並再次在該時間點為叢集輸出一個單一值。

在某個時間點的這些輸出中的每一個都會被附加到其命名的變數表達式中，這就創建了新的時間序列。結果，我們將能夠在其他時間檢查錯誤率和錯誤比率的歷史。

請求速率的規則在 Borgmon 的規則語言中會寫成如下形式：

`rate()` 函式取其包含的表達式，並返回總增量除以最早和最新值之間的總時間。

使用前面查詢的範例時間序列資料，`task:http_requests:rate10m` 規則的結果將如下所示：54
`{var=task:http_requests:rate10m,job=webserver,user=shakespeare,instance=0} 0.2`
而 `dc:http_requests:rate10m` 規則的結果將是：
`{var=dc:http_requests:rate10m,job=webserver,user=shakespeare} 1.0`
因為第二個規則使用第一個規則作為輸入。

`instance` 標籤現在在輸出中缺失，被匯總規則丟棄了。如果它保留在規則中，那麼 Borgmon 將無法將五行加在一起。

在這些例子中，我們使用一個時間窗口，因為我們處理的是時間序列中的離散點，而不是連續函式。這樣做使得速率計算比執行微積分更容易，但意味著要計算一個速率，我們需要選擇足夠數量的資料點。我們還必須處理最近的一些收集可能失敗的可能性。回想一下，歷史變數表達式表示法使用 `[10m]` 範圍來避免由收集錯誤引起的資料點丟失。

這個例子還使用了一個有助於可讀性的 Google 慣例。每個計算出的變數名都包含一個以冒號分隔的三元組，指示匯總級別、變數名以及創建該名稱的操作。在這個例子中，左手邊的變數是「任務 HTTP 請求 10 分鐘速率」和「資料中心 HTTP 請求 10 分鐘速率」。

現在我們知道如何創建一個查詢速率，我們可以在此基礎上建立，也計算一個錯誤速率，然後我們可以計算回應與請求的比率，以了解服務正在做多少有用的工作。我們可以將錯誤的**比率速率 (ratio rate)** 與我們的服務水準目標（請參閱「服務水準目標」）進行比較，如果這個目標被錯過或有被錯過的危險，就發出警報：

同樣，這個計算展示了用創建它的操作來後綴新時間序列變數名的慣例。這個結果讀作「資料中心 HTTP 錯誤 10 分鐘比率速率」。

這些規則的輸出可能如下所示：55

```
{var=task:http_responses:rate10m,job=webserver}
{var=dc:http_responses:rate10m,job=webserver}
{var=dc:http_responses:rate10m,job=webserver,code=!/200/}
{var=dc:http_errors:rate10m,job=webserver}
{var=dc:http_errors:ratio_rate10m,job=webserver}
```
前面的輸出顯示了 `dc:http_errors:rate10m` 規則中的中間查詢，該查詢過濾了非 200 的錯誤碼。儘管表達式的值相同，但請注意，`code` 標籤在一個中被保留，而在另一個中被移除。

如前所述，Borgmon 規則創建新的時間序列，因此計算結果被保存在時間序列競技場中，並且可以像源時間序列一樣被檢查。這樣做的能力允許作為表格或圖表進行臨時查詢、評估和探索。這是在值班時進行除錯的一個有用功能，如果這些臨時查詢被證明有用，它們可以被製作成服務控制台上的永久視覺化。

# 警報

當一個警報規則由 Borgmon 評估時，結果要麼是 `true`，在這種情況下警報被觸發，要麼是 `false`。經驗表明，警報可能會「抖動」(flap)（快速切換其狀態）；因此，規則允許一個警報規則必須為 `true` 的最小持續時間，然後才能發送警報。通常，這個持續時間被設定為至少兩個規則評估週期，以確保沒有遺漏的收集導致錯誤警報。

以下範例創建一個警報，當 10 分鐘內的錯誤率超過 1% 且錯誤總數超過每秒 1 個時觸發：

我們的範例將比率速率保持在 0.15，遠高於警報規則中 0.01 的閾值。然而，此時錯誤數量不大於 1，因此警報不會被啟動。一旦錯誤數量超過 1，警報將會**待定 (pending)** 兩分鐘，以確保它不是一個暫態狀態，然後才會**觸發 (fire)**。

警報規則包含一個小的範本，用於填寫包含上下文資訊的訊息：警報針對哪個工作、警報的名稱、觸發規則的數值等等。上下文資訊在警報觸發時由 Borgmon 填寫，並在 `Alert` RPC 中發送。

Borgmon 連接到一個集中運行的服務，稱為 **Alertmanager**，當規則首次觸發時，以及當警報被認為是「觸發」時，它會接收 `Alert` RPC。Alertmanager 負責將警報通知路由到正確的目的地。Alertmanager 可以被配置為執行以下操作：

- 當其他警報處於活動狀態時，抑制某些警報
- 從具有相同標籤集的多個 Borgmon 中對警報進行重複數據刪除
- 當具有相似標籤集的多個警報觸發時，根據其標籤集對警報進行扇入或扇出

如「監控分散式系統」中所述，團隊將其值得呼叫的警報發送到其值班輪換中，將其重要但次要的警報發送到其工單隊列中。所有其他警報應作為狀態儀表板的資訊性資料保留。

更全面的警報設計指南可以在「服務水準目標」中找到。

# 分片監控拓撲

一個 Borgmon 也可以從其他 Borgmon 導入時間序列資料。雖然可以嘗試從全球一個服務的所有任務中收集資料，但這樣做很快就會成為一個擴展瓶頸，並在設計中引入一個單點故障。相反，使用一種流式協定在 Borgmon 之間傳輸時間序列資料，與基於文本的 `varz` 格式相比，可以節省 CPU 時間和網路字節。一個典型的此類部署使用兩個或更多個全域 Borgmon 進行頂層匯總，並在每個資料中心使用一個 Borgmon 來監控在該位置運行的所有工作。（Google 將生產網路劃分為多個區域以進行生產變更，因此擁有兩個或更多個全域副本可以為這個原本是單點故障的系統在維護和中斷時提供多樣性。）

如圖 10-3 所示，更複雜的部署會將資料中心 Borgmon 進一步分片為一個純粹的抓取層（通常是由於單個 Borgmon 對於非常大的服務存在 RAM 和 CPU 限制）和一個主要執行匯總規則評估的 DC 匯總層。有時，全域層會在規則評估和儀表板之間進行劃分。上層 Borgmon 可以過濾它們想要從下層 Borgmon 流式傳輸的資料，這樣全域 Borgmon 就不會用來自下層的所有每個任務的時間序列填滿其競技場。因此，匯總層次結構建立了相關時間序列的本地快取，可以在需要時深入鑽取。

# 黑盒監控

Borgmon 是一個**白盒 (white-box)** 監控系統——它檢查目標服務的內部狀態，並且規則是在了解內部情況的前提下編寫的。這種模型的透明性提供了巨大的能力，可以在回應事件和測試新功能部署時，快速識別哪些組件正在失敗、哪些佇列已滿以及瓶頸在哪裡。

然而，白盒監控並不能提供被監控系統的全貌；僅僅依賴白盒監控意味著您不知道用戶看到了什麼。您只看到到達目標的查詢；由於 DNS 錯誤而從未到達的查詢是不可見的，而由於伺服器崩潰而丟失的查詢則無聲無息。您只能對您預料到的故障發出警報。

Google 的團隊用 **Prober** 來解決這個覆蓋問題，它對一個目標運行一個協定檢查並報告成功或失敗。Prober 可以直接向 Alertmanager 發送警報，或者它自己的 `varz` 可以被 Borgmon 收集。Prober 可以驗證協定的回應負載（例如，HTTP 回應的 HTML 內容），驗證內容是否符合預期，甚至可以提取並匯出值作為時間序列。團隊經常使用 Prober 來匯出按操作類型和負載大小劃分的響應時間直方圖，以便他們可以對用戶可見的性能進行切片和切塊。Prober 是檢查和測試模型與一些更豐富的變數提取以創建時間序列的混合體。

Prober 可以指向前端域或負載均衡器後面。通過使用這兩個目標，我們可以檢測到局部故障並抑制警報。例如，我們可能既監控負載均衡的 `www.google.com`，也監控負載均衡器後面的每個資料中心中的網頁伺服器。這種設定讓我們能夠在一個資料中心發生故障時知道流量仍然被服務，或者能夠快速隔離出發生故障的流量圖中的一個邊緣。

# 維護配置

Borgmon 配置將規則的定義與被監控的目標分開。這意味著同一套規則可以一次應用於許多目標，而不用一遍又一遍地編寫幾乎相同的配置。這種關注點分離可能看起來是偶然的，但它通過避免在描述目標系統時的大量重複，大大降低了維護監控的成本。

Borgmon 還支援語言範本。這個類似宏的系統使工程師能夠構建可重用的規則庫。這個功能再次減少了重複，從而降低了配置中出現錯誤的可能性。

當然，任何高層次的程式設計環境都會帶來複雜性的機會，所以 Borgmon 提供了一種通過合成時間序列資料來建立廣泛的單元和回歸測試的方法，以確保規則的行為與作者的設想一致。生產監控團隊運行一個持續整合服務，該服務執行一套這些測試，打包配置，並將配置傳送到生產中的所有 Borgmon，後者在接受配置之前會對其進行驗證。

在已創建的大量通用範本庫中，出現了兩類監控配置。第一類只是將從給定程式碼庫匯出的變數的浮現模式編碼，這樣任何使用該程式碼庫的用戶都可以重用其 `varz` 的範本。這樣的範本存在於 HTTP 伺服器函式庫、記憶體分配、儲存客戶端函式庫和通用 RPC 服務等中。（雖然 `varz` 介面沒有聲明模式，但與程式碼庫關聯的規則庫最終會聲明一個模式。）

第二類函式庫是在我們建立範本來管理從單個伺服器任務到全域服務足跡的資料匯總時出現的。這些函式庫包含用於匯出變數的通用匯總規則，工程師可以用這些規則來建模其服務的拓撲。

例如，一個服務可能提供一個單一的全域 API，但卻部署在許多資料中心。在每個資料中心內，該服務由幾個分片組成，每個分片又由幾個具有不同數量任務的工作組成。工程師可以用 Borgmon 規則來建模這種分解，以便在除錯時，可以將子組件與系統的其餘部分隔離開來。這些分組通常遵循組件的共同命運；例如，單個任務因設定檔而共享命運，一個分片中的工作因其位於同一個資料中心而共享命運，而物理站點因網路而共享命運。

標籤約定使得這種劃分成為可能：一個 Borgmon 會添加標籤，指示目標的實例名稱以及它所佔據的分片和資料中心，這些標籤可以用來對這些時間序列進行分組和匯總。

因此，我們對一個時間序列上的標籤有多種用途，儘管它們都是可以互換的：

- **定義資料本身分解的標籤**（例如，我們在 `http_responses` 變數上的 HTTP 回應碼）
- **定義資料來源的標籤**（例如，實例或工作名稱）
- **指示資料在整個服務中的位置或匯總的標籤**（例如，描述物理位置的 `zone` 標籤，描述任務邏輯分組的 `shard` 標籤）

這些函式庫的範本化特性使其使用具有靈活性。同一個範本可以用於從每個層級進行匯總。

# 十年之後…

Borgmon 將每個目標的**檢查並警報 (check-and-alert)** 模型轉置為**大規模變數收集 (mass variable collection)** 和跨時間序列的**集中式規則評估 (centralized rule evaluation)**，用於**警報和診斷 (alerting and diagnostics)**。

這種解耦使得被監控系統的規模能夠獨立於警報規則的規模進行擴展。這些規則的維護成本更低，因為它們被抽象在一個通用的時間序列格式之上。新的應用程式在所有組件和它們連結的函式庫中都帶有指標匯出，以及經過良好實踐的匯總和控制台範本，這進一步減輕了實現的負擔。

確保維護成本與服務規模呈次線性擴展，是使監控（以及所有持續的運營工作）可維護的關鍵。這個主題在所有 SRE 工作中反覆出現，因為 SRE 致力於將其工作的所有方面擴展到全球規模。

然而，十年是一段很長的時間，當然，今天 Google 內部的監控格局隨著實驗和變革而演變，隨著公司的發展而不斷追求持續改進。

儘管 Borgmon 仍然是 Google 的內部工具，但將時間序列資料視為生成警報的資料來源的想法，現在可以通過那些開源工具，如 Prometheus、Riemann、Heka 和 Bosun，以及在您閱讀本文時可能出現的其他工具，為每個人所用。

42 Prometheus 是一個開源的監控和時間序列資料庫系統，可在 https://prometheus.io 獲取。

43 Google 誕生於美國，所以我們將其發音為「var-zee」。

44 Borgmon 的複數形式是 Borgmon，就像 sheep 一樣。

45 許多非 SRE 團隊使用一個生成器來快速產生初始的樣板程式碼和持續的更新，並發現生成器比直接編輯規則更容易使用（儘管功能較弱）。

46 許多其他應用程式也使用其服務協定來匯出其內部狀態。OpenLDAP 通過 `cn=Monitor` 子樹匯出；MySQL 可以用 `SHOW VARIABLES` 查詢報告狀態；Apache 有其 `mod_status` 處理程序。

47 https://golang.org/pkg/expvar/

48 Borg 名稱系統 (BNS) 在「從 SRE 的角度看 Google 的生產環境」中有所描述。

49 回想一下「監控分散式系統」中關於對症狀發出警報和對原因發出警報的區別。

50 這個 12 小時的視界是一個神奇的數字，旨在為在 RAM 中除錯事件提供足夠的資訊，以便快速查詢，而不會花費太多 RAM。

51 為了節省空間，此處省略了 `service` 和 `zone` 標籤，但它們存在於返回的表達式中。
52 計算速率的總和而不是總和的速率，可以保護結果免受計數器重置或資料丟失的影響，這可能是由於任務重啟或資料收集失敗造成的。

53 儘管沒有類型，但大多數 `varz` 都是簡單的計數器。Borgmon 的 `rate` 函式處理了計數器重置的所有邊角情況。

54 為了節省空間，省略了 `service` 和 `zone` 標籤。
55 為了節省空間，省略了 `service` 和 `zone` 標籤。
