# 規格驅動開發 (SDD)

## 權力結構的顛覆

數十年來，程式碼一直是王者。規格文件服務於程式碼——它們只是我們建造的腳手架，一旦開始真正的編碼工作，就會被丟棄。我們撰寫 PRD 來引導開發、創建設計文件來告知實作、繪製圖表來視覺化架構。但這些永遠從屬於程式碼本身。程式碼才是真理。其他一切充其量只是良好的意圖。程式碼是真理的來源，隨著程式碼的前進，規格文件很少能跟上步伐。由於資產（程式碼）和實作是一體的，要在不試圖從程式碼構建的情況下擁有平行實作並不容易。

規格驅動開發 (SDD) 顛覆了這種權力結構。規格文件不服務於程式碼——程式碼服務於規格文件。產品需求文件 (PRD) 不是實作的指南；而是生成實作的來源。技術計劃不是告知編碼的文件；而是產生程式碼的精確定義。這不是對我們構建軟體方式的漸進改進。這是對什麼驅動開發的根本性重新思考。

規格和實作之間的差距自軟體開發誕生以來就一直困擾著我們。我們試圖通過更好的文件、更詳細的需求、更嚴格的流程來橋接這種差距。這些方法失敗是因為它們接受差距是不可避免的。它們試圖縮小差距但從未消除它。SDD 通過使從規格產生的規格及其具體實作計劃可執行來消除這種差距。當規格和實作計劃生成程式碼時，就沒有差距——只有轉換。

這種轉換現在成為可能，因為 AI 可以理解並實作複雜的規格，並創建詳細的實作計劃。但沒有結構的原始 AI 生成會產生混亂。SDD 通過規格和隨後的實作計劃提供這種結構，這些計劃足夠精確、完整且明確，可以生成工作的系統。規格成為主要工件。程式碼成為其在特定語言和框架中的表達（作為來自實作計劃的實作）。

在這個新世界中，維護軟體意味著演進規格。開發團隊的意圖以自然語言表達（"**意圖驅動開發**"），設計資產、核心原則和其他指南。開發的**通用語言**移到更高層次，程式碼是最后一里的方法。

除錯意味著修復生成不正確程式碼的規格及其實作計劃。重構意味著為清晰度進行重組。整個開發工作流程圍繞規格作為中央真理來源重新組織，實作計劃和程式碼作為持續重新生成的輸出。更新應用程式以添加新功能或因為我們是富有創造性的人而創建新的平行實作，意味著重新審視規格並創建新的實作計劃。因此這個過程是 0 → 1, (1', ..), 2, 3, N。

開發團隊專注於他們的創造力、實驗，他們的批判性思考。

## SDD 工作流程的實踐

工作流程從一個想法開始——通常模糊且不完整。通過與 AI 的迭代對話，這個想法變成一個全面的 PRD。AI 提出澄清問題，識別邊界案例，並幫助定義精確的驗收標準。在傳統開發中可能需要數天的會議和文件工作，在 SDD 中通過數小時專注的規格工作就能完成。這轉變了傳統的 SDLC——需求和設計成為持續活動而不是離散階段。這支援**團隊流程**，其中團隊審查的規格被表達、版本化、在分支中創建並合併。

當產品經理更新驗收標準時，實作計劃會自動標記受影響的技術決策。當架構師發現更好的模式時，PRD 會更新以反映新的可能性。

在整個規格過程中，研究代理收集關鍵背景。它們調查函式庫相容性、效能基準和安全影響。組織約束被自動發現並應用——您公司的資料庫標準、身份驗證需求、部署政策無縫整合到每個規格中。

從 PRD 出發，AI 生成將需求映射到技術決策的實作計劃。每個技術選擇都有記錄的理由。每個架構決策都可以追溯到具體需求。在整個過程中，一致性驗證持續改進品質。AI 分析規格的歧義、矛盾和差距——不是作為一次性門檻，而是作為持續的完善。

程式碼生成在規格及其實作計劃足夠穩定時開始，但它們不必是"完整"的。早期生成可能是探索性的——測試規格在實踐中是否有意義。領域概念成為資料模型。使用者故事成為 API 端點。驗收情境成為測試。這通過規格合併開發和測試——測試情境不是在程式碼之後編寫，它們是生成實作和測試的規格的一部分。

回饋循環延伸到初始開發之外。生產指標和事件不僅觸發熱修復——它們還更新規格以進行下一次重新生成。效能瓶頸成為新的非功能需求。安全漏洞成為影響所有未來生成的約束。在規格、實作和運營現實之間的這種迭代舞蹈中，真實的理解出現，這裡傳統的 SDLC 轉變為持續演進。

## 為什麼 SDD 現在很重要

三個趨勢使 SDD 不僅成為可能，而且是必要的：

第一，AI 能力已達到一個閾值，可以可靠地從自然語言規格生成工作的程式碼。這不是要取代開發者——而是通過自動化從規格到實作的機械翻譯來放大他們的效能。它可以放大探索和創造力，輕鬆支援"重新開始"，並支援添加、刪除和批判性思考。

第二，軟體複雜性繼續以指數級增長。現代系統整合了數十種服務、框架和依賴項。通過手動流程使所有這些部分與原始意圖保持一致變得越來越困難。SDD 通過規格驅動生成提供系統性一致性。框架可能演進為提供 AI 優先支援，而不是人類優先支援，或圍繞可重用元件進行架構設計。

第三，變化的步伐加快。需求今天變化得比以往任何時候都更快。轉向不再是例外——它是預期的。現代產品開發要求基於使用者回饋、市場條件和競爭壓力的快速迭代。傳統開發將這些變化視為干擾。每個轉向都需要手動將變化傳播通過文件、設計和程式碼。結果要么是限制速度的緩慢仔細更新，要么是積累技術債的快速魯莽變化。

SDD 可以支援假設/模擬實驗："如果我們需要重新實作或改變應用程式來促進銷售更多 T 恤的業務需求，我們將如何實作和實驗？"

SDD 將需求變更從障礙轉變為正常工作流程。當規格驅動實作時，轉向成為系統性重新生成而不是手動重寫。在 PRD 中改變核心需求，受影響的實作計劃會自動更新。修改使用者故事，對應的 API 端點會重新生成。這不僅關於初始開發——還關於通過不可避免的變化維持工程速度。

## 核心原則

**規格作為通用語言**：規格成為主要工件。程式碼成為其在特定語言和框架中的表達。維護軟體意味著演進規格。

**可執行的規格**：規格必須足夠精確、完整且明確，可以生成工作的系統。這消除了意圖和實作之間的差距。

**持續完善**：一致性驗證持續發生，而不是一次性門檻。AI 作為持續過程分析規格的歧義、矛盾和差距。

**研究驅動的背景**：研究代理在整個規格過程中收集關鍵背景，調查技術選項、效能影響和組織約束。

**雙向回饋**：生產現實告知規格演進。指標、事件和運營學習成為規格完善的輸入。

**分支探索**：從相同規格生成多個實作方法，以探索不同的優化目標——效能、可維護性、使用者體驗、成本。

## 實作方法

今天，實踐 SDD 需要組裝現有工具並在整個過程中維持紀律。這種方法可以使用以下工具實踐：

- AI 助手用於迭代規格開發
- 研究代理用於收集技術背景
- 程式碼生成工具用於將規格轉換為實作
- 適應規格優先工作流程的版本控制系統
- 通過 AI 分析規格文件進行一致性檢查

關鍵是將規格視為真理的來源，程式碼作為服務於規格而不是相反的生成輸出。

## 使用命令簡化 SDD

SDD 方法通過三個強大的命令得到顯著增強，這些命令自動化規格 → 計劃 → 任務的工作流程：

### `/speckit.specify` 命令

此命令將簡單的功能描述（使用者提示）轉換為完整的結構化規格，並自動進行倉庫管理：

1. **自動功能編號**：掃描現有規格以確定下一個功能編號（例如，001、002、003）
2. **分支創建**：從您的描述生成語義分支名稱並自動創建
3. **基於模板的生成**：複製並自訂功能規格模板以滿足您的需求
4. **目錄結構**：創建適當的 `specs/[branch-name]/` 結構用於所有相關文件

### `/speckit.plan` 命令

一旦功能規格存在，此命令創建一個全面的實作計劃：

1. **規格分析**：讀取並理解功能需求、使用案例和驗收標準
2. **憲法合規**：確保與專案憲法和架構原則保持一致
3. **技術轉換**：將業務需求轉換為技術架構和實作細節
4. **詳細文件**：為資料模型、API 合約和測試情境生成支援文件
5. **快速啟動驗證**：產生捕獲關鍵驗證情境的快速啟動指南

### `/speckit.tasks` 命令

創建計劃後，此命令分析計劃和相關設計文件以生成可執行的任務列表：

1. **輸入**：讀取 `plan.md`（必需）和存在的 `data-model.md`、`contracts/`、`research.md`
2. **任務衍生**：將合約、實體和情境轉換為具體任務
3. **並行化**：標記獨立任務 `[P]` 並概述安全並行組
4. **輸出**：在功能目錄中寫入 `tasks.md`，準備由任務代理執行

### 範例：建置聊天功能

以下是這些命令如何轉變傳統開發工作流程：

**傳統方法：**

```text
1. 在文件中撰寫 PRD（2-3 小時）
2. 創建設計文件（2-3 小時）
3. 手動設定專案結構（30 分鐘）
4. 撰寫技術規格（3-4 小時）
5. 創建測試計劃（2 小時）
總計：約 12 小時的文件工作
```

**使用命令的 SDD 方法：**

```bash
# 步驟 1：創建功能規格（5 分鐘）
/speckit.specify 具有訊息歷史和使用者存在的即時聊天系統

# 這會自動：
# - 創建分支 "003-chat-system"
# - 生成 specs/003-chat-system/spec.md
# - 使用結構化需求填充

# 步驟 2：生成實作計劃（5 分鐘）
/speckit.plan WebSocket 用於即時訊息、PostgreSQL 用於歷史、Redis 用於存在

# 步驟 3：生成可執行任務（5 分鐘）
/speckit.tasks

# 這會自動創建：
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md (WebSocket 函式庫比較)
# - specs/003-chat-system/data-model.md (訊息和使用者架構)
# - specs/003-chat-system/contracts/ (WebSocket 事件、REST 端點)
# - specs/003-chat-system/quickstart.md (關鍵驗證情境)
# - specs/003-chat-system/tasks.md (從計劃衍生的任務列表)
```

在 15 分鐘內，您擁有：

- 包含使用者故事和驗收標準的完整功能規格
- 具有技術選擇和理由的詳細實作計劃
- 準備用於程式碼生成的 API 合約和資料模型
- 適用於自動化和手動測試的全面測試情境
- 在功能分支中正確版本化的所有文件

### 結構化自動化的力量

這些命令不僅節省時間——它們還強制一致性和完整性：

1. **沒有遺漏的細節**：模板確保考慮每個方面，從非功能需求到錯誤處理
2. **可追溯的決策**：每個技術選擇都連結回具體需求
3. **活的文件**：規格與程式碼保持同步，因為它們生成程式碼
4. **快速迭代**：在幾分鐘內改變需求並重新生成計劃，而不是幾天

這些命令通過將規格視為可執行工件而不是靜態文件來體現 SDD 原則。它們將規格過程從必要的邪惡轉變為開發的驅動力。

### 模板驅動品質：結構如何約束 LLM 以獲得更好的結果

這些命令的真正力量不僅在於自動化，還在於模板如何引導 LLM 行為朝向更高品質的規格。模板充當複雜的提示，通過生產性方式約束 LLM 的輸出：

#### 1. **防止過早的實作細節**

功能規格模板明確指示：

```text
- ✅ 專注於使用者需要什麼以及為什麼
- ❌ 避免如何實作（無技術棧、API、程式碼結構）
```

這種約束迫使 LLM 維持適當的抽象層次。當 LLM 可能自然跳到"使用 React 和 Redux 實作"時，模板讓它專注於"使用者需要即時更新他們的資料"。這種分離確保規格在實作技術變化時保持穩定。

#### 2. **強制明確的不確定性標記**

兩個模板都要求使用 `[NEEDS CLARIFICATION]` 標記：

```text
從使用者提示創建此規格時：
1. **標記所有歧義**：使用 [NEEDS CLARIFICATION: 具體問題]
2. **不要猜測**：如果提示沒有指定某件事，請標記
```

這防止了 LLM 常見的行為——做出看似合理但可能不正確的假設。LLM 必須標記為 `[NEEDS CLARIFICATION: 認證方法未指定 - email/password, SSO, OAuth?]`，而不是猜測"登入系統"使用 email/password 認證。

#### 3. **通過檢查清單進行結構化思考**

模板包含全面的檢查清單，充當規格的"單元測試"：

```markdown
### 需求完整性
- [ ] 沒有 [NEEDS CLARIFICATION] 標記保留
- [ ] 需求可測試且明確
- [ ] 成功標準可衡量
```

這些檢查清單迫使 LLM 系統性地自我審查其輸出，捕捉可能溜過的差距。這就像給 LLM 一個品質保證框架。

#### 4. **通過門檻強制憲法合規**

實作計劃模板通過階段門檻強制架構原則：

```markdown
### 階段 -1：實作前門檻
#### 簡潔門檻 (第七條)
- [ ] 使用 ≤3 個專案？
- [ ] 沒有未來防護？
#### 反抽象門檻 (第八條)
- [ ] 直接使用框架？
- [ ] 單一模型表示？
```

這些門檻通過迫使 LLM 明確證明任何複雜度來防止過度工程。如果門檻失敗，LLM 必須在"複雜度追蹤"章節中記錄原因，創造架構決策的問責制。

#### 5. **層次化細節管理**

模板強制適當的資訊架構：

```text
**重要**：此實作計劃應保持高層次且可讀。
任何程式碼範例、詳細演算法或廣泛的技術規格
必須放置在適當的 `implementation-details/` 文件中
```

這防止了規格變成不可讀的程式碼傾卸的常見問題。LLM 學習維持適當的細節層次，將複雜度提取到單獨的文件中，同時保持主要文件可導航。

#### 6. **測試優先思考**

實作模板強制測試優先開發：

```text
### 文件創建順序
1. 使用 API 規格創建 `contracts/`
2. 按順序創建測試文件：合約 → 整合 → e2e → 單元
3. 創建來源文件以使測試通過
```

這種順序約束確保 LLM 在實作之前考慮可測試性和合約，導致更強大和可驗證的規格。

#### 7. **防止投機功能**

模板明確阻止投機：

```text
- [ ] 沒有投機性或"可能需要"的功能
- [ ] 所有階段都有明確的先決條件和交付物
```

這阻止 LLM 添加使實作複雜化的"nice to have"功能。每個功能必須追溯到具有明確驗收標準的具體使用者故事。

### 複合效應

這些約束共同產生：

- **完整**：檢查清單確保沒有遺漏
- **明確**：強制澄清標記突出不確定性
- **可測試**：測試優先思考融入過程
- **可維護**：適當的抽象層次和資訊層次
- **可實作**：具有具體交付物的清晰階段

模板將 LLM 從創意作家轉變為紀律嚴明的規格工程師，引導其能力朝向產生一致高品質、可執行的規格，真正驅動開發。

## 憲法基礎：強制架構紀律

SDD 的核心是一個憲法——一套不可變的原則，治理規格如何變成程式碼。憲法 (`memory/constitution.md`) 充當系統的架構 DNA，確保每個生成的實作維持一致性、簡潔性和品質。

### 開發的九條

憲法定義了九條塑造開發過程每個方面的條文：

#### 第一條：函式庫優先原則

每個功能必須從獨立的函式庫開始——沒有例外。這從一開始就強制模組化設計：

```text
Specify 中的每個功能必須從獨立的函式庫開始存在。
沒有功能應在應用程式程式碼中直接實作而不
先被抽象成可重用的函式庫元件。
```

此原則確保規格生成模組化、可重用的程式碼而不是單體應用程式。當 LLM 生成實作計劃時，它必須將功能結構化為具有清晰邊界和最小依賴項的函式庫。

#### 第二條：CLI 介面強制

每個函式庫必須通過命令列介面公開其功能：

```text
所有 CLI 介面必須：
- 接受文字作為輸入（通過 stdin、參數或文件）
- 產生文字作為輸出（通過 stdout）
- 支援 JSON 格式進行結構化資料交換
```

這強制可觀測性和可測試性。LLM 無法將功能隱藏在不透明的類別中——一切都必須通過基於文字的介面存取和驗證。

#### 第三條：測試優先命令

最具變革性的條文——測試之前沒有程式碼：

```text
這是不可協商的：所有實作必須遵循嚴格的測試驅動開發。
在以下情況之前不得編寫實作程式碼：
1. 單元測試已編寫
2. 測試已由使用者驗證和批准
3. 測試確認為 FAIL（Red 階段）
```

這完全顛覆傳統的 AI 程式碼生成。LLM 不是生成程式碼並希望它工作，而必須首先生成定義行為的全面測試，獲得批准，然後才生成實作。

#### 第七條和第八條：簡潔性和反抽象

這些配對條文對抗過度工程：

```text
第 7.3 節：最小專案結構
- 初始實作最多 3 個專案
- 額外專案需要記錄理由

第 8.1 節：框架信任
- 直接使用框架功能而不是包裝它們
```

當 LLM 可能自然創建精緻的抽象時，這些條文迫使它證明每個複雜度層次。實作計劃模板的"階段 -1 門檻"直接強制這些原則。

#### 第九條：整合優先測試

優先考慮真實世界的測試而不是隔離的單元測試：

```text
測試必須使用真實環境：
- 優先使用真實資料庫而不是模擬
- 使用實際服務實例而不是存根
- 實作前合約測試強制性
```

這確保生成的程式碼在實踐中工作，而不僅僅在理論上。

### 通過模板強制憲法合規

實作計劃模板通過具體檢查點將這些條文操作化：

```markdown
### 階段 -1：實作前門檻
#### 簡潔門檻 (第七條)
- [ ] 使用 ≤3 個專案？
- [ ] 沒有未來防護？

#### 反抽象門檻 (第八條)
- [ ] 直接使用框架？
- [ ] 單一模型表示？

#### 整合優先門檻 (第九條)
- [ ] 合約已定義？
- [ ] 合約測試已編寫？
```

這些門檻充當架構原則的編譯時檢查。LLM 無法繼續，除非通過門檻或在"複雜度追蹤"章節中記錄合理的例外。

### 不可變原則的力量

憲法的力量在於其不可變性。雖然實作細節可以演進，但核心原則保持不變。這提供：

1. **時間一致性**：今天生成的程式碼遵循與明年相同的原則
2. **LLM 間一致性**：不同的 AI 模型產生架構相容的程式碼
3. **架構完整性**：每個功能強化而不是破壞系統設計
4. **品質保證**：測試優先、函式庫優先和簡潔原則確保可維護的程式碼

### 憲法演進

雖然原則不可變，但它們的應用可以演進：

```text
第 4.2 節：修正過程
對此憲法的修改需要：
- 明確記錄變更理由
- 專案維護者審查和批准
- 回溯相容性評估
```

這允許方法論學習和改進，同時維持穩定性。憲法顯示其自身的演進，並記錄修訂日期，展示原則如何基於真實經驗被完善。

### 超越規則：開發哲學

憲法不僅僅是規則書——它是塑造 LLM 如何思考程式碼生成的哲學：

- **可觀測性優於不透明**：一切都必須通過 CLI 介面檢查
- **簡潔性優於聰明**：從簡單開始，只有在證明必要時才添加複雜度
- **整合優於隔離**：在真實環境中測試，而不是人工環境
- **模組化優於單體**：每個功能都是具有清晰邊界的函式庫

通過將這些原則嵌入規格和計劃過程，SDD 確保生成的程式碼不僅功能性——還可維護、可測試和架構健全。憲法將 AI 從程式碼生成器轉變為尊重和強化系統設計原則的架構夥伴。

## 轉變

這不是要取代開發者或自動化創造力。而是通過自動化機械翻譯來放大人類能力。這是關於創建一個緊密的回饋循環，其中規格、研究和程式碼一起演進，每次迭代帶來更深的理解和意圖與實作之間更好的對齊。

軟體開發需要更好的工具來維持意圖與實作之間的一致性。SDD 通過生成程式碼而不是僅僅指導的可執行規格提供實現這種對齊的方法論。
