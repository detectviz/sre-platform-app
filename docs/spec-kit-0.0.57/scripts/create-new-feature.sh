#!/usr/bin/env bash
# =============================================================================
# Spec Kit - 新功能建立腳本 (create-new-feature.sh)
# =============================================================================
# 此腳本用於建立新的功能分支和相關的規格文件結構
# 它會自動產生編號、建立分支，並初始化必要的目錄和文件
# =============================================================================

# 遇到錯誤立即退出，提高腳本可靠性
set -e

# =============================================================================
# 參數解析區塊
# =============================================================================

# 初始化變數
JSON_MODE=false  # 是否以 JSON 格式輸出
ARGS=()          # 儲存位置參數

# 循環處理所有命令列參數
for arg in "$@"; do
    case "$arg" in
        --json)
            # 啟用 JSON 輸出模式，用於程式化呼叫
            JSON_MODE=true
            ;;
        --help|-h)
            # 顯示幫助資訊並退出
            echo "使用方式：$0 [--json] <功能描述>"
            echo ""
            echo "參數說明："
            echo "  --json           以 JSON 格式輸出結果"
            echo "  <功能描述>      新功能的文字描述（必填）"
            echo ""
            echo "功能說明："
            echo "  此腳本會根據功能描述建立新的功能分支"
            echo "  自動產生編號、建立 Git 分支和初始化規格文件"
            exit 0
            ;;
        *)
            # 將位置參數儲存起來
            ARGS+=("$arg")
            ;;
    esac
done

# 將所有位置參數合併為功能描述
FEATURE_DESCRIPTION="${ARGS[*]}"

# 驗證功能描述是否提供
if [ -z "$FEATURE_DESCRIPTION" ]; then
    echo "錯誤：必須提供功能描述" >&2
    echo "使用方式：$0 [--json] <功能描述>" >&2
    exit 1
fi

# =============================================================================
# 工具函數區塊
# =============================================================================

# 通過搜尋儲存庫標記來找到儲存庫根目錄的函數
# 支援 .git 目錄和 .specify 目錄作為標記
find_repo_root() {
    local dir="$1"

    # 從當前目錄開始向上搜尋
    while [ "$dir" != "/" ]; do
        # 檢查是否存在儲存庫標記
        if [ -d "$dir/.git" ] || [ -d "$dir/.specify" ]; then
            echo "$dir"
            return 0
        fi
        # 移動到父目錄
        dir="$(dirname "$dir")"
    done

    # 如果到達根目錄仍未找到，返回錯誤
    return 1
}

# =============================================================================
# 儲存庫根目錄解析區塊
# =============================================================================

# 解析儲存庫根目錄。優先使用 git 資訊（如果可用），但後備到搜尋儲存庫標記，
# 這樣在以 --no-git 初始化儲存庫時工作流程仍然能運作。
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# 嘗試使用 git 命令取得儲存庫根目錄
if git rev-parse --show-toplevel >/dev/null 2>&1; then
    REPO_ROOT=$(git rev-parse --show-toplevel)
    HAS_GIT=true
else
    # 如果 git 不可用，使用自定義函數搜尋
    REPO_ROOT="$(find_repo_root "$SCRIPT_DIR")"
    if [ -z "$REPO_ROOT" ]; then
        echo "錯誤：無法確定儲存庫根目錄。請在儲存庫內執行此腳本。" >&2
        exit 1
    fi
    HAS_GIT=false
fi

# 切換到儲存庫根目錄
cd "$REPO_ROOT"

# =============================================================================
# 功能編號產生區塊
# =============================================================================

# 定義規格目錄路徑
SPECS_DIR="$REPO_ROOT/specs"
mkdir -p "$SPECS_DIR"

# 尋找現有功能目錄中的最高編號
HIGHEST=0
if [ -d "$SPECS_DIR" ]; then
    # 遍歷所有子目錄
    for dir in "$SPECS_DIR"/*; do
        # 跳過非目錄項目
        [ -d "$dir" ] || continue

        # 取得目錄名稱
        dirname=$(basename "$dir")

        # 從目錄名稱中提取數字部分
        number=$(echo "$dirname" | grep -o '^[0-9]\+' || echo "0")

        # 轉換為十進制數字（處理前導零）
        number=$((10#$number))

        # 更新最高編號
        if [ "$number" -gt "$HIGHEST" ]; then
            HIGHEST=$number
        fi
    done
fi

# 計算下一個編號
NEXT=$((HIGHEST + 1))
FEATURE_NUM=$(printf "%03d" "$NEXT")

# =============================================================================
# 分支名稱產生區塊
# =============================================================================

# 將功能描述轉換為有效的分支名稱：
# 1. 轉換為小寫
# 2. 將非字母數字字符替換為連字號
# 3. 壓縮多個連字號為單個
# 4. 移除開頭和結尾的連字號
BRANCH_NAME=$(echo "$FEATURE_DESCRIPTION" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g' | sed 's/^-//' | sed 's/-$//')

# 從分支名稱中提取前三個單字作為簡短描述
WORDS=$(echo "$BRANCH_NAME" | tr '-' '\n' | grep -v '^$' | head -3 | tr '\n' '-' | sed 's/-$//')

# 組合最終的分支名稱：編號-關鍵字
BRANCH_NAME="${FEATURE_NUM}-${WORDS}"

# =============================================================================
# Git 分支建立區塊
# =============================================================================

# 如果是 Git 儲存庫，建立新分支
if [ "$HAS_GIT" = true ]; then
    git checkout -b "$BRANCH_NAME"
else
    # 如果不是 Git 儲存庫，發出警告但繼續執行
    >&2 echo "[specify] 警告：未偵測到 Git 儲存庫；跳過 $BRANCH_NAME 的分支建立"
fi

# =============================================================================
# 目錄和文件建立區塊
# =============================================================================

# 建立功能目錄
FEATURE_DIR="$SPECS_DIR/$BRANCH_NAME"
mkdir -p "$FEATURE_DIR"

# 從模板複製規格文件
TEMPLATE="$REPO_ROOT/.specify/templates/spec-template.md"
SPEC_FILE="$FEATURE_DIR/spec.md"

# 如果模板存在就複製，否則建立空文件
if [ -f "$TEMPLATE" ]; then
    cp "$TEMPLATE" "$SPEC_FILE"
else
    touch "$SPEC_FILE"
fi

# =============================================================================
# 環境變數設定區塊
# =============================================================================

# 設定 SPECIFY_FEATURE 環境變數供當前工作階段使用
export SPECIFY_FEATURE="$BRANCH_NAME"

# =============================================================================
# 輸出結果區塊
# =============================================================================

# 根據輸出模式顯示結果
if $JSON_MODE; then
    # JSON 格式輸出，適用於腳本整合
    printf '{"BRANCH_NAME":"%s","SPEC_FILE":"%s","FEATURE_NUM":"%s"}\n' "$BRANCH_NAME" "$SPEC_FILE" "$FEATURE_NUM"
else
    # 人類可讀的格式輸出
    echo "分支名稱：$BRANCH_NAME"
    echo "規格文件：$SPEC_FILE"
    echo "功能編號：$FEATURE_NUM"
    echo "SPECIFY_FEATURE 環境變數已設定為：$BRANCH_NAME"
fi
